JVM
================
1. JVM 内存划分
    JDK7：堆、虚拟机栈、本地方法栈、方法区、程序计数器
    JDK8：堆、虚拟机栈、本地方法栈、元空间、程序计数器
    线程共享有：堆、方法区、元空间
    线程私有有：虚拟机栈、本地方法栈、程序计数器
    可GC的有：堆、方法区
    区别：
    7中运行时常量池从永久代中移除，在堆中开辟了一块区域存放运行时常量池
    8中没有永久代，将方法区直接放在一个与堆不相连的本地内存区域，叫做元空间
2. 什么时候触发Young GC，什么时候触发Full GC
    Minor GC 针对 新生代（Eden和Survivor）
    Major GC 针对 Tenured区，回收老年代
    Full  GC 针对 新生代、老年代、元空间全局范围的GC，
   Young GC时机：
   1) 当 Eden区空间不足
   Full GC时机: 
   1）System.gc  建议执行；
   2）老年代空间不足；
   3）方法区空间不足；
   4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
   5) 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
3. Young GC 会不会触发STW
    STW：Stop-The-World，
    1）JVM GC需要通过发起系统调用write()记录GC行为；
    2) write()调用可以被后台磁盘IO所阻塞
    3) 记录GC日志属于JVM停顿的一部分，因此write()调用的时候也会被记录到STW的时间内

4. CMS垃圾回收算法分为哪几个阶段
    参考：https://www.cnblogs.com/Leo_wl/p/5393300.html
   CMS： Concurrent Mark Sweep，针对老年代收集，会扫描新生代
   6个阶段：
   1）初始标记(STW)：进行可达性分析，标记GC ROOT能直接关联到的对象
   2）并发标记：GC ROOT TRACING，间接关联的对象
   3）并发预清理：
   4）重标记(STW)：暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。
        有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。
        注意这个阶段是多线程的。
   5）并发清理：并发清理。用户线程被重新激活，同时清理那些无效的对象。
   6）重置： CMS清除内部状态，为下次回收做准备。
5. G1 收集器
6. new Object过程
    1）java文件编译成class文件
    2) new 时，检查有没有父类，有父类，classloader加载父类class文件，读入内存，创建父类class类对象，然后加载子类，classloader加载子类class文件，读入内存，创建子类class类对象；
        2.1）加载：生成java.lang.Class对象
        2.2）验证：保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 
        2.3）准备：类变量分配内存并设置类变量的初始值，在方法区中分配这些变量所使用的内存空间。
            public static int v = 8080;//初始化为0 类构造器<clinit>
            如果是：
            public static final int v = 8080;// 初始化为8080
        2.4）解析：该阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
            如：CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info类型的常量；
            直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
        2.5）初始化：执行<clinit>类构造器的过程。<clinit>方法是有编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成。虚拟机会保证<clinit>方法执行前，父类的<clinit>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以为这个类生成<clinit>方法；
        2.6）使用（运行时） 
        2.7）卸载（垃圾回收）
    3）先初始化父类的静态属性，再初始化父类的静态代码块；
    4）初始化子类的静态属性，在初始化子类的静态代码；
    5）在堆内存中分配内存空间，分配内存地址，父类的特有属性才在堆中分配空间。
    6）初始化父类特有属性
    7）初始化父类的构造代码块
    8）初始化父类对象响应的构造方法
    9）在堆内存中分配内存空间，分配内存地址，此时是因为子类的特有属性才在堆内存中为子类对象分配空间的。
    10）初始化子类的特有属性。
    11）初始化子类的构造代码块。
    12）初始化子类相应的构造方法。 
    13）将子类的内存地址赋值给栈中的引用对象。
7.类加载机制
    参考：http://www.importnew.com/25295.html
    三种类加载器：
    1）启动类加载器（Bootstrap CLassLoader）：JAVA_HOME/lib
    2）扩展类加载类（Extension ClassLoader）：JAVA_HOME/lib/ext
    3）应用程序类加载器（Applicatioin ClassLoader）：用户路径classpath
    双亲委派模型：
    当一个类加载器收到类加载请求时，先交给父类加载器完成，最终加载任务会传递到顶层的启动类加载器，只有当父类加载器无法完成类加载任务时，子类才会尝试加载。

多线程
================
1.volatile 可以保证线程安全吗？
    不可以；
    参考：https://www.cnblogs.com/dolphin0520/p/3920373.html
    回答此问题涉及多个知识点：
    1）解释内存模型
    2）解释CPU三级及主存关系
    3）解决CPU缓存不一致问题（总线加锁、缓存一致性协议（MESI））
        3.1）缓存一致性协议：它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
    4）并发概念
        4.1）原子性：
        4.2）可见性：多个CPU，其中一个CPU更新缓存，但没有同步到主存，此时出现可见性问题；
        4.3）顺序性：指令重排，前提是结果正确，否则不会指令重排，如果遇到多线程指令重排会引起问题，如果保证并发执行的正确性，必须保证顺序性；
    5）JMM
        JMM定义变量的访问规则；
        JMM规定所有变量都是存在主存中（物理内存），每个线程都有自己的工作内存（CPU缓存/高速缓存）；
        线程对变量的操作都必须在工作内存中进行，不能直接对主存操作；
        工作内存相互独立；
        Java语言如何保证原子性、可见性、顺序性？
        5.1）原子性
            在Java中，对基本类型变量的读取和赋值操作都是原子性；
            举例分析一下是否是原子性操作：
            x=10;//原子性；赋值操作，10赋值给x，在工作内存中；
            y=x; //非原子性；分两步：第一步：从主存中读取x 第二步：将读取的x写到工作内存；两步都是原子性，但是两个原子性合起来 不是原子性；
            x++;//非原子性；读取x，+1，回写工作内存；
            x = x -1;//非原子性
            以上只能保证基本类型变量的读取、赋值是原子性；
            如何要保证更大范围的原子性？
                Synchronized、Lock
        5.2）可见性
            Java提供volatile关键字来保证可见性；
            volatile int count = 0；
            如果count被修改，Java保证count值立即被更新到主存中，当有其他线程需要读取count时，去主存中读取新值；
            但是普通变量不能保证什么时候被写入主存，无法保证可见性；
            synchronized和Lock也能保证可见性，保证同一时刻只有一个线程执行同步代码，释放锁之前会将变量修改刷新到主存中。可以保证可见性；
        5.3）有序性
            JMM中，允许编译器和处理器对指令进行重排，但是不会影响单线程的执行，却会影响到多线程并发执行的正确性。
            Java中，可以通过valotile、synchronized、lock保证有序性；
            Happens-before原则 保证有序性；
            5.3.1）程序次序规则：一个线程内，书写顺序执行；
            5.3.2）锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
            5.3.3）valatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作？？？？？
            5.3.4）传递规则：A先B,B先C => A先C
            5.3.5）线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
            5.3.6）线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
            5.3.7）线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
            5.3.8）对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
    6）volatile关键字
        该关键字两层语义：
        6.1）保证多个线程的可见性；//立即写入主存
        6.2）禁止指令重排；
            举例：
            x = 2;        //语句1
            y = 0;        //语句2
            volatile flag = true;  //语句3
            x = 4;         //语句4
            y = -1;       //语句5 
            volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
        6.3）不保证原子性；
            i++;//包括三个操作：读、+1、写入工作内存；

        如何保证并发i++原子性：
        synchronized/Lock/CAS(硬件指令CMPXCHG)/AtomicInteger       
    7）volatile的原理和实现机制
         加入volatile关键字生成汇编代码多出lock前缀指令，实际上相当于一个内存屏障，其3个功能：
         7.1）确保后面的指令不会被排到内存屏障之前的位置，前面的指令不会被排到内存屏障后面的位置；内存屏障指令执行时，表示前面的指令已经全部完成；
         7.2）强制将兑缓存的修改立即写入主存；
         7.3）如果是写操作，将导致其他CPU中对应的缓存行失效；
    8）volatile适用场景
        8.1）状态标记
        8.2）double-check
        8.3）原子类CAS
2. Synchronized关键字的作用，性能如何优化？
    作用：控制多线程访问共享资源；
    涉及多个知识点：
    2.1）三种用法
        2.1.1）静态方法：类对象
        2.1.2）普通方法：实例对象
        2.1.3）代码块：实例对象：monitorenter、monitorexit
    2.2）ObjectMonitor
    2.3) ObjectWaiter
    2.4) 
3. JVM 锁优化
    3.1）适应性自旋：
        忙循环/自旋次数，根据“长、短“ 采取不同策略等待
    3.2）锁消除
        根据”逃逸分析“，代码不存在竞争，就不需要加锁。比如StringBuffer.append()
    3.3）锁粗化
        如果一系列操作都对同一个对象反复加锁解锁，就会把锁的范围扩大，避免频繁加锁解锁操作
    3.4）轻量级锁
        作用：在没有多线程竞争的前提下，减少传统的重量级锁使用的操作系统互斥量产生的性能损耗。
        对象头中Mark Word结构：
            对象哈希码、对象分代年龄；
            指向锁记录的指针；
            指向重量级锁的指针；
            空；
            偏向线程ID、偏向时间戳、分代年龄
        轻量级锁加锁过程：
            >首先线程栈中创建锁记录空间，用来存放对象头MarkWord的拷贝；
            >CAS修改对象头MarkWord更新为栈帧中锁记录的指针，如果更新成功，表示拥有锁，并且对象MarkWord的标志位转变为00
            >如果CAS更新失败，判断当前对象头MarkWord是否指向当前线程栈帧，如果不是，表示有其他线程抢占，如果有两条以上的线程竞争同一锁，那轻量级锁不再有效，膨胀为重量级锁；锁标志转为10，MarkWord中存储的就是指向重量级锁的指针。
            
    3.5）偏向锁
        作用：在无竞争的情况下把整个同步都消除掉，连CAS都不做；
        偏向第一个获得他的线程，以后该线程不再同步；使用CAS修改MarkWord的线程ID。
4. JMM Happens-Before原则/指令
    4.1）先行发生原则：
        程序次序规则；
        管程锁定规则；
        volatile变量规则；
        线程启动规则；
        线程终止规则；
        线程中断规则；
        对象终结规则；
        传递性；
    4.2）8指令
        4.2.1）read：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
        4.2.2）load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
        4.2.3）use：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
        4.2.4）assign：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
        4.2.5）store：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
        4.2.6）write：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
        4.2.7）lock
        4.2.8）unlock
5. Java线程池参数的含义
        5.1）如果运行线程少于corePoolSize，创建新线程来执行任务
        5.2）如果运行线程等于或大于corePoolSize，则加入阻塞队列
        5.3）如果无法加入阻塞队列，则创建新的线程来处理任务；
        5.4）如果创建新线程超出maxPoolSize，任务将被拒绝，并调用RejectExecutionHandler.rejectedExecution方法
        饱和策略：
            AbortPolicy：直接抛出异常
            CallerRunsPolicy：调用者所在的线程运行任务
            DiscardOldestPolicy：丢弃队列中最近的一个任务，并执行当前任务；
            DiscardPolicy：不处理，丢弃掉

6. 线程池执行任务的过程
    参考：https://blog.csdn.net/u011240877/article/details/73440993
    当提交一个新任务时：
    6.1）线程池判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务。如果池里的线程都在执行任务，进入下一个流程：
    6.2）线程池判断工作队列已满。如果没满，则加入队列，如果满了，则进入下一个流程：
    6.3）线程池判断线程池的线程是否处于工作状态，如没有，则创建一个新的工作线程来执行任务，如果已经满了，交给饱和策略来处理这个任务；

7. 如何配置线程池？
    7.1）CPU密集型，线程数与CPU个数相当
    7.2）IO密集型，由于阻塞等待，cpu*2
    7.3）阻塞队列选择：一般情况下使用有界队列；暴增业务需求使用无界队列；
    7.4）吞吐量：使用无阻塞队列CAS操作可以提高吞吐量


集合
================
1.HashMap
    参考：https://github.com/553899811/NewBie-Plan/blob/master/Java%E5%9F%BA%E7%A1%80/Java-%E5%AE%B9%E5%99%A8/Map/HashMap.md
    参考：http://www.importnew.com/20386.html
    数组+链表；
    初始化桶：16个；最大值2^30，put时初始化
    桶的大小或者数组的大小：不是任意值，而是2的幂，通过tableSizeFor()方法得来
    扩容时机：16*0.75=12，扩容*2；
    链表转红黑树时：链表长度到达8时；
    红黑树转链表：链表节点长度较少到6时；
    JDK7：
    JDK8：引入红黑树
2.ConcurrentHashMap
    参考：http://www.importnew.com/23610.html
    参考：http://ifeve.com/concurrenthashmap/
    并发Map，采用分段锁（重入锁）
    JDK7：
    JDK8：

3.CopyOnWriteArrayList
    并发容器，读写分离思想，读时不用加锁，写时加锁（重入锁）
    加入元素时，先复制当前容器，将新元素加入新容器，然后将原容器的引用指向新容器；
    实现：ReentrantLock/Array.copyOf()/
    特点：可以在遍历时修改，普通集合在遍历时修改抛出异常；
    应用场景：读多写少的场景
    缺点：内存占用大，写时性能差

Redis
================
1.Redis的两种持久化方式
    1.1)RDB/snapshotting（默认）
        默认存储到dump.rdb文件，可手动执行save或者bgsave命令，
        创建快照的方式：
        save命令：主线程运行，会阻塞请求；
        bgsave命令：Fork子进程运行
        配置文件策略：
            save 900 1//900秒之内，如果超过1个key被修改，则发起快照保存；
            save 300 10//300秒内，如果超过10个key被修改，则发起快照保存
        数据丢失：丢失最近一次快照之后的所有操作；
    1.2)AOF
        写命令追加存储到appendonly.aof
        配置文件：
            appendonly yes//开启
            appendfsync everysec//默认每秒持久化一次
            appendfsync always//每次操作都会写入aof文件，效率低
    区别：
    1）RDB 方式 记录整个数据集的所有信息，恢复快，Fork子进程对主进程不影响；
    2）AOF 记录命令操作，丢失少，多个命令Redis有优化策略；
2.Redis支持的数据结构五种对象类型
    Redis数据库键是字符串对象，值可以是五种对象类型，分别如下：
    2.1）REDIS_STRING    字符串对象(整形、浮点型、字符串)
        key/value存储
        命令：set/get/setex/setnx/incrby/incr/decrby/decr/exists/del/expire
        底层实现：或intset整数集合
    2.2）REDIS_LIST  列表对象
        双端链表结构
        命令：lpush/rpush/lrange/rpushx/lindex/lset/lrem/lpop/rpop/ltrim/linsert/rpoplpush
        底层实现：linkedlist和ziplist
    2.3）REDIS_HASH  哈希对象
        命令：hset/hget/hexist/hlen/hsetnx/hmset/hmget/hincrby/hincrby/hkeys/hvals/hgetall
        eg：hset(key,field,value)
        eg: hget(key,field)
        底层实现：散列
    2.4）REDIS_SET   集合对象
        命令：sadd/srem/smove/sismember/smembers
        底层实现：
    2.5）REDIS_ZSET  有序集合对象
        命令：zadd/
        底层实现：skiplist跳跃表和散列表
3.Redis8种底层数据结构
    REDIS_ENCODING_INT  long 类型的整数
    REDIS_ENCODING_EMBSTR   embstr 编码的简单动态字符串
    REDIS_ENCODING_RAW  简单动态字符串
    REDIS_ENCODING_HT   字典
    REDIS_ENCODING_LINKEDLIST   双端链表
    REDIS_ENCODING_ZIPLIST  压缩列表
        当列表、散列、有序集合的长度较短或者体积较小，Redis选择ziplist压缩列表紧凑方式来存储。
    REDIS_ENCODING_INTSET   整数集合
    REDIS_ENCODING_SKIPLIST 跳跃表和字典
4. Redis键过期时间
    4.1）针对列表、集合、有序结合、散列此类容器，只能针对整个键设置过期时间，而不能对其中元素设置过期时间；
    4.2）容器元素设置过期时间：通过对单个元素存储时间戳来实现


Mysql
================
1.函数（索引列）可以使用索引吗？
    1.1) MYSQL索引类型：
        normal：普通索引
        unique：唯一索引
        full text：全文索引
        单列、多列：
        最左前缀：多列索引
    1.2）MYSQL 索引失效的场景：
        只对<,<=,=,>,>=,between,in使用索引，like 中不以%开头的情况
        1.2.1) where != 
        1.2.2) where day(col1), where字句条件用函数
        1.2.3）join中，主键和外检的数据类型相同时才使用
        1.2.4）在order by中，MYSQL只有在排序条件下不是一个查询条件表达式的情况下使用
        1.2.5）数据列中有许多重复值，索引不会有好效果
        1.2.6）条件中 or 不适用，除非or 前后列都加索引
        1.2.7）字符串列，必须在查询条件中 使用 引号，否则不适用
        1.2.8）like 以%开头 不适用
        1.2.9）索引列进行计算 where age-1=8 ,索引失效
        1.2.10）where rount(id)=10，函数 索引失效
    1.3）索引考虑
        
        where 和 join使用的列
    1.4）Hash索引
        缺点：
            1.4.1）不能使用范围查询，仅仅满足 = in <=>,因为是计算后的hash值
            1.4.2) 无法避免数据排序，hash前后的顺序不一定一直
            1.4.3）Hash索引不能利用部分索引键查询，对于组合索引。
            1.4.4）如果遇到大量Hash值相等情况，性能不一定比B-Tree高
    1.5）B-Tree索引
        参考：https://www.jianshu.com/p/486a514b0ded
        1.5.1)B+Tree
            B-Tree树的变种，只有leaf node存储数据，其他节点存储key；
            Mysql中的B+Tree在经典的B+Tree基础上进行了优化，增加了顺序访问指针，在每个叶子节点增加了一个指向相邻叶子节点的指针，形成了带有顺序访问指针的B+Tree。
            优点：
                提高了区间访问性能：如果要查找key为从18到49的访问数据，当涨到18后，只需要顺着指针顺序遍历就可以一次性访问到所有的数据节点，极大的提高了区间查询效率，无需返回上层父节点重复遍历查找，减少IO次数。
            磁盘存取原理：
                索引以文件形式存储在磁盘上，需要IO操作，耗费巨大。磁盘的IO寻址最耗时。
                磁盘的寻址是指：将数据逻辑地址 按照 寻址逻辑将地址翻译成物理地址，确定磁道、扇区。此过程需要寻道/寻道时间；
            局部性原理与磁盘预读：
                磁盘和主存以页（逻辑块-4K）为单位交换数据， 磁盘每次是预读，预读的数据大小是页的整数倍。
                若程序读取的数据不在主存，会触发缺页异常，此时系统向磁盘发出读盘信号，磁盘找到数据起始位置向后读取1页或者几页载入内存。
        1.5.2）B-/+Tree性能衡量指标：磁盘I/O次数
            1. mysql结合系统存储结构优化处理，磁盘结构和磁盘预读；
            2. B+Tree单个节点能放多个子节点，相同IO次数
            3. B+Tree只在叶子节点存储数据/叶子节点包含指针。利用索引快速定位数据索引范围，先定位索引在通过索引高效快速定位数据。
            4. Mysql设计利用了磁盘预读原理 
                将一个B+Tree节点大小设为一个页的大小，在新建节点时申请一个页的大小空间，这样就能保证一个节点物理上存储在一个页里，加之计算机存储分配都是按照页对齐的，这样实现一个节点只需一次IO操作。
                B-Tree、B+Tree单个节点能放多个子节点，查询IO次数相同（mysql查询io次数最多3-5次，所以需要每个节点需要存储很多数据）
            5. B+Tree更适合外存索引，和节点出度d有关，d越大索引性能越好，因为B+Tree内节点去掉了Data区，因此可以拥有更大的出度，拥有更好的性能。
        1.5.3）B+Tree 在MyISAM和InnoDB 中底层实现不同
            1. MyISAM采用非聚簇索引
                myi索引文件 和 myd 数据 文件分离，索引文件又保存数据记录的指针。
                叶子节点data域存储指向数据记录的指针地址。
                存储结构：frm-表定义、myi-myisam索引、myd-myisam数据
            2. InnoDB采用 聚簇索引
                采用聚簇索引- InnoDB数据&索引文件为一个idb文件，表数据文件本身就是主索引，相邻的索引临近存储。 叶节点data域保存了完整的数据记录(数据[除主键id外其他列data]+主索引[索引key:表主键id])。 叶子节点直接存储数据记录，以主键id为key,叶子节点中直接存储数据记录。(底层存储结构: frm -表定义、 ibd: innoDB数据&索引文件)

2.索引的左侧原则？
    2.1）联合索引：索引可以建立在多列上，
        联合索引的最左原则就是建立索引KEY union_index (a,b,c)时，等于建立了(a)、(a,b)、(a,b,c)三个索引，从形式上看就是索引向左侧聚集，所以叫做最左原则，因此最常用的条件应该放到联合索引的组左侧。
        利用联合索引加速查询时，联合查询条件符合“交换律”，也就是where a = 1 and b = 1 等价于 where b = 1 and a = 1，这两种写法都能利用索引KEY union_index (a,b,c)。

3.三大日志的作用binlog、undolog、redolog
    3.1) binlog
        Mysql Server层的记录日志，用于记录所有更新且提交了数据或者已经潜在更新提交了数据的所有语句，以”事件“的形式保存，它描述数据更改。
        作用：
            用于恢复；
            记录所有发送给从服务器的语句；
    3.2) Undolog
        3.2.1）作用：
            为了实现事务的原子性；
            辅助完成事务持久化；
            InnoDB引擎用来实现MVCC；
        3.2.2）原理：
            为了满足原子性，操作任何数据之前，先将数据备份到一个地方（Undolo）->修改数据，如果出现错误或者用户执行rollback，系统可以利用Undolog中的备份数据恢复事务开始之前的状态。
        3.2.3）缺陷
            每个事务提交前将数据和Undolog写入磁盘，这样导致大量的磁盘IO，因此性能很低。
            如果数据能够将数据缓存一段时间，就能够较少IO，提高性能；
    3.3) Redolog
        Innodb存储引擎层的日志，记录的是新数据的备份。事务提交前，只要将RedoLog持久化即可，不需要将数据持久化，当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化，系统就可以根据Redolog内容将所有数据恢复到最新的状态。
4.Mysql 5.5、5.6、5.7在主从同步上做了哪些改进
    4.1）Mysql复制架构演进史：
        > MySQL 3.23.15   Replication,准后实时同步方式，复制由两个线程，Master中一个，Slave一个线程：负责I/O和Sql，无relay log，
            这种模式缺点：读取event时间得速度受限于apply速度；较大延迟时，导致大量bin log没有备份到Slave
        > MySQL 4.0.2 Slave端 读取event的I/O和执行SQL的线程独立，同时引入relay log；
            I/O线程读取event事件后写入relay log，SQL线程从relay log读取event执行SQL，即使SQL执行慢，不会影响I/O线程，Master的bin log会尽可能的同步到Slave。当Master宕机不会出现大量数据丢失；
        > MySQL 5.5之前采用异步复制方式：主库的事务执行不关心从库的备份进度，如果备库延迟，主库，将导致数据丢失。于是5.5 引入半同步复制，主库在应答Client提交事务之前至少保证一个从库接收并写入relay log。
        
        > MySQL 5.6版本引入并发复制（schema级别），基于schema级别的并发复制核心思想：“不同schema下的表并发提交时的数据不会相互影响，即slave节点可以用对relay log中不同的schema各分配一个类似SQL功能的线程，来重放relay log中主库已经提交的事务，保持数据与主库一致”。可见MySQL5.6版本的并发复制，一个schema分配一个类似SQL线程的功能。
        
        > MYSQL 5.7.17，引入：InnoDB Group Replication，全同步方式
        
    4.2）MySQL三种复制方式
        4.2.1) asynchronous 异步复制
            主库线程把binlog事件写入binlog后，主库只会通知dump线程发送binlog日志而后继续处理提交操作，此时并不会保证binlog传到任何一个从库节点上；
            流程：
            1）正常的复制为：事务一（t1）写入binlog buffer；dumper线程通知slave有新的事务t1；binlog buffer进行checkpoint；slave的io线程接收到t1并写入到自己的的relay log；slave的sql线程写入到本地数据库。 这时，master和slave都能看到这条新的事务，即使master挂了，slave可以提升为新的master。

            2）异常的复制为：事务一（t1）写入binlog buffer；dumper线程通知slave有新的事务t1；binlog buffer进行checkpoint；slave因为网络不稳定，一直没有收到t1；master挂掉，slave提升为新的master，t1丢失。

            3）很大的问题是：主机和从机事务更新的不同步，就算是没有网络或者其他系统的异常，当业务并发上来时，slave因为要顺序执行master批量事务，导致很大的延迟。

        4.2.2) Semisynchronous 半同步复制
            介于异步和全同步之间，主库只需要等待至少一个从库节点收到并且Flush Binlog到Relay Log文件即可，主库无需等待从库反馈。同时，这里只是一个收到的反馈，而不是已经完全执行并且提交的反馈。
            特点：
            1. Dumper线程任务是发送通知和接收slave的ack；
            2. Master的事务会阻塞等待，等待会超时，超时后关闭版同步复制，转换为异步复制。
            3. 从库只有在接收到主库的某一事务的所有binlog，并且写入并fulsh到relaylog文件之后，才会通知主库的dumper线程，
            4. 数据不一致的问题，由于master等待从回馈ACK导致
            5. 5.7版本对半同步复制的改进是 无损复制 loss-less semi-Synchronous模式（AFTER_SYNC）：在binlog sync之后，在engine层commit之前 等待Slave ACK，如此可以利用Group commit，有利于性能提升。
            半同步复制（AFTER_COMMIT 5.6默认）和无损复制（AFTER_SYNC 5.7默认）：
                区别一：时间点不同
                    - 半同步复制是innodb层commit log后等待ack，主从切换有丢失数据风险；
                    - 无损复制是在innodb层收到write binlog之后，等待ack，主从切换会有数据变多风险。
                区别二：数据不一致性
                    - 半同步复制意味着在Master节点上，这个刚刚提交的事物对数据库的修改，对其他事物是可见的。因此，如果在等待Slave ACK的时候crash了，那么会对其他事务出现幻读，数据丢失。
                    - 无损复制在write binlog完成后，就传输binlog，但还没有去写commit log，意味着当前这个事物对数据库的修改，其他事物也是不可见的。因此，不会出现幻读，数据丢失风险。因此5.7引入了无损复制（after_sync）模式，带来的主要收益是解决after_commit导致的master crash后数据丢失问题，因此在引入after_sync模式后，所有提交的数据已经都被复制，故障切换时数据一致性将得到提升。
                区别三：性能提升，支持发送binlog和接收ack异步化
                    旧semi sync受限于dump thread，因为dump thread承担了传送binlog给slave和等待接收slave反馈任务，且串行，dump thread必须等待slave返回之后才会传送下一个events事务。dump thread 已然成为整个半同步提高性能的瓶颈。高并发时，影响TPS。
                    5.7的semi sync，独立出一个Ack Receiver线程，专门用于接收Slave返回的ack请求，将之前发送和接收工作分为两个线程来处理，可并行处理。极大提高性能。5.7.17版本前，Ack Receiver线程采用select机制监听slave返回，由于select 1024fd限制会导致宕机。因此5.7.17版本后，采用poll机制，poll与select没有本质区别，只是句柄没有上限，都是基于链表来存储；缺点：大量的fd需要在用户态和内核态之间切换，再者，poll的水平触发使得第一次没有处理的fd会在下次再次报告。
                区别四：性能提升，控制主库接收slave写事务成功反馈数量
                    
                    MySQL 5.7新增了rpl_semi_sync_master_wait_slave_count参数，可以控制主库接收多少个slave写事务成功反馈。
                区别五：性能提升，Binlog互斥锁改进

                    - 旧版本半同步复制在提交binlog的写会话和dump thread读binlog的操作都会对binlog添加互斥锁，导致binlog文件的读写是串行化的，并发性能极低；
                    - MYSQL5.7 对binlog lock进行了两方面优化
                        - 移除dump thread对binlog的互斥锁；
                        - 加入安全边际保证binlog的读安全；
        4.2.3) fully synchronous 全同步复制
            主库提交事务后，所有从库节点都必须收到Apply并且提交这些事务，然后主库线程才能继续做后续操作；
            缺点：主库完成一个事务的时间被拉长，性能降低。
    4.3）MYSQL并行复制的改进
        并行复制涉及 生产者-消费者模式，任务队列
        参考：https://www.kancloud.cn/thinkphp/mysql-parallel-applier/45908
        4.3.1）单线程复制
        4.3.2）5.6 支持并行复制，引入GTID
            基于schema，也就是基于库的，如果用户的MYSQL数据库实例中存在多个schema，对于从机复制速度的确可以有大幅度提升；
        4.3.3）5.7 真正的并行复制
            基于组提交，Slave服务器的回放与主机是一致的。一组提交的事务可以并行回放，因为这些事务已经进入prepare阶段。
            GTID支持基于组的并行复制，通过GTID识别哪个组；
    4.4）各版本变化：
        主从同步：主执行提交之后，将语句记录到binlog，
        从 启动一个IO线程从主传输到本地，进入本地的relaylog；
        从 另启一个SQL线程负责顺序执行relaylog中的语句，
        问题：IO性能损耗；从机数据延迟；主宕机有脏数据；
        5.5版本： 加入半同步复制
            作用：优化了复制脏数据存在；
            原理：
        5.6版本： 加入GTID（全局事务ID），加入了多线程复制和组提交的新模式
            5.6.1）GTID实际上是由UUID+TID组成，
                UUID是MYSQL实例的唯一标识；
                TID标识该实例上已经提交的事务数量，且递增；
                GTID的目的：
                    判断事务发生在哪个实例上；
                    方便Replication的Failover，M宕机的情况下，能迅速根据GTID找到同步停止点。
            5.6.2）多线程并发复制
                针对多库的情况，开启多线程，每个库有独立的IO线程，可以交叉并发传输。提高多库业务的复制速度。
            5.6.3）组提交
                提升了binlog和innodb的redolog的落盘效率；
                多个事务同时执行完成，数据需要持久化到log中时，会全部进入待提交队列。最先进入队列的事务线程成为leader线程，其后进入的为follower线程，leader线程会获得一个锁，全权负责本次队列中的所有事务的落盘操作，接着联系其他follower线程，将他们的提交内容获取到，并让他们等待自己完成操作，接着这个leader线程会进入后续的落盘过程，等完成后，会通知本队列的所有follower线程落盘已经完成，可以返回成功状态了。
                好处：
                    多次磁盘IO合并成一次IO，减少读写次数，有待提高
        5.7版本： 多线程复制
            5.7是主从复制上一个划时代版本，在原来组提交优化了磁盘IO效率的基础上，将组提交的模式应用到了主从网络IO上，对网络效率进行了同样的优化，官方称之为：Enhanced Multi-Threaded Slave（简称MTS），增强的多线程备份。
5.MYSQL线程模型
    5.0）区分连接池和线程池
        5.0.1)连接池在客户端设置：作用是避免频繁创建和销毁连接
        5.0.2)线程池在DB服务器设置：超过最大设置，进入队列，控制MYSQL服务器活动线程数目；高并发时保护DB
            连接和线程模型不是1:1，而是M:N;
        5.0.3）MYSQL线程池架构：
            ThreadPool由一个Timer线程和多个Thread Group，每个Group又由两个队列、一个lintener线程和多个worker线程构成。
            - 队列：用来存放执行的IO任务，分高优先级和低优先级：事务语句放高
            - listener线程：监听该线程Group的语句，并确定当自己变成worker线程，是立即执行语句还是入队，判断标准是 队列是否有待执行的语句
            - worker线程：干活的线程
            - Timer线程：用来周期性检查Group是否阻塞，若阻塞，则唤醒或者new线程来解决，queue_event_count 和IO任务队列是否为空来判断。
        5.0.4）Thread Pool工作流程：
            1. 请求进入Mysql，根据threadID%/thread_pool_size确定Group；
            2. Group的listener线程监听有新的请求时，检查队列是否有请求还未处理 。若无，自己转换为worker立即处理该请求，如果队列还有未处理的请求，则将该请求入队，让其他线程处理；
            3. Group中的thread线程检查队列的请求，若队列有请求，则进行处理，否则休眠，查过thread_pool_idle_timeout自动退出。
            4. Timer线程检查各Group是否有阻塞，若有，就对worker线程唤醒或创建新worker线程。
        5.0.5）Thread Pool分配机制
            线程池根据thread_poo_size分成若干Group，每个Group各自维护客户端连接，客户端发起连接时，会根据threadid对thread_pool_size取模，落到对应Group
            thread_pool_oversubscribe参数控制每个group的最大并发线程数，每个group的最大并发线程数为thread_pool_oversubscribe+1个。若对应的group达到了最大的并发线程数，则对应的连接就需要等待。这个分配机制在某个group中有多个慢SQL的场景下会导致普通的SQL运行时间很长，


    5.1）MYSQL SERVER层线程模型
        5.1.1）采用poll机制为客户端每个链接创建一个线程；
        5.1.2）ThreadCache减少创建线程的开销，有waiting_thd_list队列/
        mysql_cond_wait/signal/mysql_mutex_unlock/条件变量：COND_thread_cache/
        并没有对线程并发进行控制；线程切换性能损耗严重；
        5.1.3）有linstner线程，worker线程，优先级队列，普通队列，dumper线程
    5.2）MYSQL 存储引擎层InnoDB线程模型
        5.2.1）可配置引擎层线程并发数量，线程进入内核需要申请tickets，两种申请方式：一是内核通过mutex和cond实现tickets申请；一是无锁方式（while-true循环）申请tickets。申请不到tickets的线程进入等待；

        5.2.2）Thread Pool，解绑连接 和线程，epoll实现
6.索引结构，B+树各个引擎实现有何不同？
7.引擎区别，为何默认是innodb或者myisam
    5.5之前是MyIASM，之后是innodb
    1、MyIASM是非事务安全的，而InnoDB是事务安全的
    2、MyIASM锁的粒度是表级的，而InnoDB支持行级锁
    3、MyIASM支持全文类型索引，而InnoDB不支持全文索引
    4、MyIASM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyIASM
    5、MyIASM表保存成文件形式，跨平台使用更加方便
8.MVCC机制
    数据库并发事务控制方法之一，
    7.1）并发事务控制有三种：
        悲观锁：最常用，锁两种模式：读锁共享锁/写锁排他锁
            读写锁、
        乐观锁: 
            基于时间戳的乐观并发协议：
                每个事务都拥有一个全局唯一的时间戳（系统时钟/计数器），保证唯一且递增；
            基于验证的协议：
                读->验证->写，三个时间戳
        多版本控制MVCC：
            每个写事务都创建一个版本，每个读事务会挑选合适的版本进行读
    7.2）Mysql与MVCC
        Mysql将MVCC与2PC取优结合，每个版本的数据行都有唯一的时间戳，读事务取最大时间戳的行；写事务：先读取最新版本数据，计算，创建新版本（时间戳：目前数据行版本+1），     

算法
================
1.单链表找倒数第n个
    参考：https://blog.csdn.net/wangyukl/article/details/67071892
    - 解题思路：创建两个指向head的指针p q,让p遍历，p先开始移动，p走到第n-1个节点是，之后p q 一起往后移动，这时候当p指向最后一个节点的时候，q就指向了倒数第n个节点的位置，这时候返回q就可以了。


业务
================
1. 锁定账号2小时，解锁，如何实现？
    延迟队列:
    Redis 列表：值为时间戳，时间不到，重新入队
    Redis 有序集合：时间为分值，循环获取排名第一的任务；也可以准备一个立即执行的队列用来存放需要立即执行的任务；
    MQ:
工程
================
