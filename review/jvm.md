JVM
================
1. JVM 内存划分
    JDK7：堆、虚拟机栈、本地方法栈、方法区、程序计数器
    JDK8：堆、虚拟机栈、本地方法栈、元空间、程序计数器
    线程共享有：堆、方法区、元空间
    线程私有有：虚拟机栈、本地方法栈、程序计数器
    可GC的有：堆、方法区
    区别：
    7中运行时常量池从永久代中移除，在堆中开辟了一块区域存放运行时常量池
    8中没有永久代，将方法区直接放在一个与堆不相连的本地内存区域，叫做元空间
2. 什么时候触发Young GC，什么时候触发Full GC
    Minor GC 针对 新生代（Eden和Survivor）
    Major GC 针对 Tenured区，回收老年代
    Full  GC 针对 新生代、老年代、元空间全局范围的GC，
   Young GC时机：
   1) 当 Eden区空间不足
   Full GC时机: 
   1）System.gc  建议执行；
   2）老年代空间不足；
   3）方法区空间不足；
   4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
   5) 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
3. Young GC 会不会触发STW
    STW：Stop-The-World；
    0）为什么会引起STW？
        
    1）JVM GC需要通过发起系统调用write()记录GC行为；
    2) write()调用可以被后台磁盘IO所阻塞
    3) 记录GC日志属于JVM停顿的一部分，因此write()调用的时候也会被记录到STW的时间内

4. CMS垃圾回收算法分为哪几个阶段
    参考：https://www.cnblogs.com/Leo_wl/p/5393300.html
   CMS： Concurrent Mark Sweep，针对老年代收集，会扫描新生代
   6个阶段：
   1）初始标记(STW)：进行可达性分析，标记GC ROOT能直接关联到的对象
   2）并发标记：GC ROOT TRACING，间接关联的对象
   3）并发预清理：
   4）重标记(STW)：暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。
        有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。
        注意这个阶段是多线程的。
   5）并发清理：并发清理。用户线程被重新激活，同时清理那些无效的对象。
   6）重置： CMS清除内部状态，为下次回收做准备。
5. G1 收集器
6. new Object过程
    1）java文件编译成class文件
    2) new 时，检查有没有父类，有父类，classloader加载父类class文件，读入内存，创建父类class类对象，然后加载子类，classloader加载子类class文件，读入内存，创建子类class类对象；
        2.1）加载：生成java.lang.Class对象
        2.2）验证：保证Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 
        2.3）准备：类变量分配内存并设置类变量的初始值，在方法区中分配这些变量所使用的内存空间。
            public static int v = 8080;//初始化为0 类构造器<clinit>
            如果是：
            public static final int v = 8080;// 初始化为8080
        2.4）解析：该阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
            如：CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info类型的常量；
            直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
        2.5）初始化：执行<clinit>类构造器的过程。<clinit>方法是有编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成。虚拟机会保证<clinit>方法执行前，父类的<clinit>方法已经执行完毕。如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以为这个类生成<clinit>方法；
        2.6）使用（运行时） 
        2.7）卸载（垃圾回收）
    3）先初始化父类的静态属性，再初始化父类的静态代码块；
    4）初始化子类的静态属性，在初始化子类的静态代码；
    5）在堆内存中分配内存空间，分配内存地址，父类的特有属性才在堆中分配空间。
    6）初始化父类特有属性
    7）初始化父类的构造代码块
    8）初始化父类对象响应的构造方法
    9）在堆内存中分配内存空间，分配内存地址，此时是因为子类的特有属性才在堆内存中为子类对象分配空间的。
    10）初始化子类的特有属性。
    11）初始化子类的构造代码块。
    12）初始化子类相应的构造方法。 
    13）将子类的内存地址赋值给栈中的引用对象。
7.类加载机制
    参考：http://www.importnew.com/25295.html
    三种类加载器：
    1）启动类加载器（Bootstrap CLassLoader）：JAVA_HOME/lib
    2）扩展类加载类（Extension ClassLoader）：JAVA_HOME/lib/ext
    3）应用程序类加载器（Applicatioin ClassLoader）：用户路径classpath
    双亲委派模型：
    当一个类加载器收到类加载请求时，先交给父类加载器完成，最终加载任务会传递到顶层的启动类加载器，只有当父类加载器无法完成类加载任务时，子类才会尝试加载。
